---
title: csapp阅读笔记——计算机系统漫游
date: 2020-04-14 18:21:24
categories: csapp
tags: [csapp,notes,深入理解计算机系统]
---

# 计算机系统漫游

计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。

![https://i.quantuminit.com/2e501a1eebe44afa.png](https://i.quantuminit.com/2e501a1eebe44afa.png)

## 信息就是位 + 上下文

hello 程序的生命周期是从一个源程序（或者说源文件）开始的，即程序员通过编辑器创建并保存的文本文件，文件名 hello.c。源程序实际上是一个由值 0 和 1 组成的位（又称比特）序列，8 个位组成的一个组，称之为**字节**。每个字节表示程序中的某些文本字符。只有 ASCII 字符构成的文件称为**文本文件**，所有其他文件都称为**二进制文件*。

![https://i.quantuminit.com/c30693fca1994049.png](https://i.quantuminit.com/c30693fca1994049.png)

hello.c 程序是以字节序列的方式储存在文件中的。hello.c 的表示方法说明了一个基本思想：系统中的所有信息————包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。

区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。

## 程序被其他程序翻译成不同的格式

hello 程序的生命周期是从一个高级 C 语言程序开始，因为这种方式能够被人读懂。但为了在系统能够运行 hello.c 程序，需要将这一我们可读的，对于计算机来说是高级语言的程序转换为机器能够理解的低级机器语言指令。然后将这些指令按照一种称为**可执行目标程序*的格式打好包，并以二进制磁盘文件的形式保存起来。目标程序也称为*可执行目标文件*。

在 Unix 上，由**编译器驱动程序**完成源文件到目标文件转化过程：

```sh
gcc -o hello hello.c
```

这个转换过程可分为四个阶段，执行这些阶段的程序构成了一个**编译系统**：

1. *预处理器*
2. *编译器*
3. *汇编器*
4. *链接器*

![https://i.quantuminit.com/d246b3ca236a4e25.png](https://i.quantuminit.com/d246b3ca236a4e25.png)

- 预处理器。该处理器（cpp）根据 # 开头字符的命令修改原始 C 程序。比如 hello.c 中的 `#include <stdio.h>`命令告诉预处理器读取系统文件 `stdio.h`的内容，并插入到 hello.c 文本文件中。通常是的到一个以.i为文件扩展名的另一个 C 程序。

- 编译器。编译器（ccl）将预处理器生成的文本文件 hello.i 翻译成包含一个汇编语言程序的文本文件 hello.s。该程序包含函数 main 的定义：

![https://i.quantuminit.com/19eb1fc16f884f2d.png](https://i.quantuminit.com/19eb1fc16f884f2d.png)

- 汇编阶段。汇编器（as）将包含汇编语言程序的 hello.s 翻译成机器语言指令，将这些命令打包成一个称为**可重定位目标程序**的格式，并保存在目标文件 hello.o 中。此时，hello.o 是一个二进制文件，其包含的 17 个字节是函数 main 的指令编码。
- 链接阶段。hello 程序调用 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。链接器负责将存在于预编译好的 printf.o文件中 中的 printf 函数，以某种方式合并到 hello.o 中来。最后得到一个可被加载到内存中由系统执行的可执行目标文件（或简称为可执行文件）。

## 了解编译系统如何工作是大有益处的

- 优化程序性能。比如一个函数的调用开销有多大？指针引用比数组索引更有效吗？为什么将循环球和的结果放到本地变量中，会比将其放到一个通过引用传递过来的参数中，运行其快很多呢？
- 理解链接时出现的错误。比如链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？在不同的 C 文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？更为严重的是，为什么有些链接错误直到运行时才会出现？
- 避免安全漏洞。缓冲区溢出错误是造成大多数网络和 Internet 服务器安全漏洞的主要原因。学习安全变成的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。学习到汇编语言的时候，将会描述栈原理和缓冲区溢出错误。

## 处理器读并解释储存在内存中的指令

在此之前，hello.c 已经被编译系统编译出了可以被载入内存运行的可执行目标文件 hello，并被存储在磁盘上。此时，我们想在 Unix 系统上执行目标程序，需要将文件输入到称为 shell 的应用程序中：

```sh
$ ./hello
hello, world
```

那么什么是 shell 呢？这个英语单词在中文中的意思是壳，贝壳。我们知道贝壳的壳很硬，这么硬有部分原因肯定是想保护内部柔软的核心的。我们知识迁移到计算机操作系统中，计算机操作系统主要由两部分组成：操作系统和 shell 组成。我们这里讲的是Unix系统。那么shell 它是一个命令行解释器，同时也是起到保护计算机操作系统内核的作用。它输出一个提示符，等待输入一个命令行，然后执行用户输入的这个命令。

![https://i.quantuminit.com/f4ec18a9d70e4133.svg](https://i.quantuminit.com/f4ec18a9d70e4133.svg)

### 系统的硬件组成

1. 总线

    贯穿整个系统的一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。有的是 4 个字节，有的是 8 个字节。

2. I/O设备

    I/O(输入/输出)设备是系统与外部世界的联系通道。这里的实例系统包括四个I/O设备：作为用户输入的鼠标和键盘，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（即磁盘）。每个 I/O 设备通过一个*控制器*或*适配器*与 I/O 总线相连。控制器和适配器之间的区别主要在于他们的封装方式。**控制器**是 I/O 设备本身或者系统的主印制电路板（即主板）上的芯片组。适配器则是一块插在主板插槽上的卡。但他们的功能都是在 I/O 总线和 I/O 设备之间传递信息。

    ![https://i.quantuminit.com/da08e95947d2461b.png](https://i.quantuminit.com/da08e95947d2461b.png)

3. 主存

    *主存*是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是一组*动态随机存取存储器*（DRAM）芯片组成。而从逻辑上来说，存储器是一个线性的字节数组，每个自己都有其唯一的地址（数组索引），这些地址是从零开始的。

4. 处理器

    *中央处理单元（CPU）*，简称（*处理器*），是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或*寄存器*），称为*程序计数器*(PC)。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。

    处理器执行指令的顺序是由**指令级架构**决定。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和内存中刚刚执行的指令相邻。

    这样简单的操作围绕着主存、**寄存器文件**（register file）和算术/逻辑单元（ALU）进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU 计算新的数据和地址。

    CPU 在指令的要求下可能会执行这些操作：

    - 加载： 从内存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容
    - 存储：从寄存器复制一个字节或者一个字到贮存的某个位置，以覆盖这个位置上原来的内容。
    - 操作：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。
    - 跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖原来的值。

将处理器的指令集架构和处理器的**微体系架构**区分开：指令架构描述的是每条机器代码指令的效果；而微体系架构描述的是处理器实际上是如何实现的。

### 运行 hello 程序

初始时，shell 程序执行它的指令，等待输入一个命令。当输入字符串“./hello”之后，shell 程序将字符逐一读入寄存器，将其放到内存中。

![https://i.quantuminit.com/b7736672b9e14b96.png](https://i.quantuminit.com/b7736672b9e14b96.png)

当敲下键盘键盘上的回车键时，shell 程序就知道已经输入完命令。shell 程序执行一系列指令来加载可执行的 hello 文件，将 hello 目标文件中的代码和数据从磁盘复制到主存。其中也包括最后要显示的“hello, world\n”。

利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从磁盘到达内存。

![https://i.quantuminit.com/36ce1861ef1b4c38.png](https://i.quantuminit.com/36ce1861ef1b4c38.png)

在目标文件 hello 程序中的代码被加载到主存以后，处理器处理则开始执行 hello 程序的 main 函数中的机器语言指令。这些指令将字符串“hello, world\n”数据复制到寄存器，再从寄存器复制到显示设备上，并最终显示出来。

![https://i.quantuminit.com/aba4b8df31de4413.png](https://i.quantuminit.com/aba4b8df31de4413.png)

## 告诉缓存至关重要

从上面执行 hello 程序的指令中可以看出，数据在被显示出来之前，一直处于从某个存储器复制到另外一个存储器的过程中。从程序员的角度来看，这些复制就是开销，减慢了程序“真正”的工作。因此系统设计者的一个主要目标就是使这些复制的操作尽可能快地完成。

根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价高于同类的低速设备。

处理器从寄存器文件中读取数据要比从主存中读取几乎要快 100 倍。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。

为了解决处理器和主存之间的这种差距，系统设计者采用了更小更快的存储设备，称为*高速缓存存储器*（cache memory，简称为 cache 或高速缓存），作为暂时集结区域，用来存放处理器近期可能会使用的信息。位于处理器芯片上的 L1 高速缓存的容量可以达到数万字节，其访问速度接近于访问寄存器的速度。而 L2 高速缓存器容量可达到数十万到数百万字节，它通过一条特殊的总线连接到处理器。L1 和 L2 高速缓存使用一种叫做 **静态随机访问存储器**（SRAM）的硬件技术来实现。比较新的处理器要还有 L3 高速缓存。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了告诉**缓存的局部性**原理。

![https://i.quantuminit.com/9812ee33dcfc4593.png](https://i.quantuminit.com/9812ee33dcfc4593.png)

## 存储设备形成层次结构

![https://i.quantuminit.com/d72a17d58a814e44.png](https://i.quantuminit.com/d72a17d58a814e44.png)

存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，从层次结构的上方到下方，每一层都是下一层的高速缓存。分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。

## 操作系统管理硬件

hello 程序依靠操作系统提供的服务来访问键盘，磁盘或主存。应用程序尝试对硬件的操作都必须通过操作系统。

![https://i.quantuminit.com/bfbbae7afb6340ee.png](https://i.quantuminit.com/bfbbae7afb6340ee.png)

操作系统有两个基本功能：

1. 防止硬件被失控的应用程序滥用
2. 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（**进程**、**虚拟内存**、**文件**）来实现这两个功能。

![https://i.quantuminit.com/4d4d0387f5a24730.png](https://i.quantuminit.com/4d4d0387f5a24730.png)

### 进程

**进程**是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时晕新多个进程，而每个进程都好像在独占使用硬件。**并发运行**，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多余可以运行它们的 CPU 个数的。无论单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程见切换来实现的。操作系统实现这种交错执行的机制称为**上下文**切换。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如 PC 和寄存器文件的当前值，以及主存的内容。在任一时刻，单处理器系统都只能执行一个今晨个的代码。当操作系统决定把控制权从当前进程转移到某个新进程是，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程从上次停止的地方开始。

![https://i.quantuminit.com/92e8393943f8487b.png](https://i.quantuminit.com/92e8393943f8487b.png)

当我们通过 shell 程序运行 hello 程序时，这里就产生了俩个并发进程。最开始，只有 shell 进程在运行，即等待命令行上的输入。当我们让它运行hello 程序时，shell 通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。

从一个进程到另一个进程的切换是有关操作系统内核（kernel）管理的。内核是操作系统代码常驻主存的部分。内核不是一个独立的进程。相反，它是系统管理全部进程所有代码和数据结构的集合。

![https://i.quantuminit.com/92e8393943f8487b.png](https://i.quantuminit.com/92e8393943f8487b.png)

### 线程

在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个县城都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为县城一般来说都比进程更高效。

### 虚拟内存

**虚拟内存**是一个抽象概念，它为每个进程提供了一个假象，及每个进程都在独占地使用贮存。每个进程看到的内存都是一致的，称为**虚拟地址空间**。Linux 进程的虚拟地址空间（其他 Unix 系统的设计也与此类似）。在 Linux 中，地址空间最上面的区域是保留给操作系统中的代码和数据的。地址空间的底部区域存放用户进程定义的代码和数据。

![https://i.quantuminit.com/e8a78e144cc547a8.png](https://i.quantuminit.com/e8a78e144cc547a8.png)

每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。这里先简单了解每个区。从最低的地址开始，逐步向上介绍。

- 程序代码和数据。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。
- 堆。代码和数据区后紧随着的是运行时**堆**。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 malloc 和 free 这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。
- 共享库。大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。
- 栈。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次调用一个函数时，栈都会增长；从一个函数返回时，栈就会收缩。
- 内核虚拟地址。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。而是必须通过调用内核来执行这些操作。

虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。进本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的告诉缓存。

### 文件

文件就是字节序列，仅此而已。系统中的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现。文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看代系统中可能含有的所有各式各样的 I/O 设备。

## 系统之间利用网络通信

现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个 I/O 设备。

![https://i.quantuminit.com/4c06b9acc501409f.png](https://i.quantuminit.com/4c06b9acc501409f.png)

## 重要主题

系统是硬件和系统软件互相交织的集合体，它们共同协作以达到运行应用程序的最终目的。

### Amdahl 定律

这一定律是一个叫 Gene Amdahl 的人的观察得出。定律的主要思想是，当我们对系统的某个部分加速是，其对系统整体性能的影响取决与该部分的重要性和加速程度。假设系统执行某个应用程序使用时间 T<sub>old</sub>。若系统某部分所需执行时间与这个时间的比例为 α，而后来部分性能提升的比例为 k。即该部分系统初始所需时间为 αT<sub>old</sub>，现在执行初始时间是(αT<sub>old</sub>)/k。因此，新的总执行时间应该为 T<sub>new</sub> = (1-α)T<sub>old</sub> + (αT<sub>old</sub>)/k。

![https://i.quantuminit.com/af5db97cb6594354.svg](https://i.quantuminit.com/af5db97cb6594354.svg)

由此可以计算出加速比 S = T<sub>old</sub>/T<sub>new</sub> 为 S = 1 / ((1 - α) + (α/k))

Amdahl 定律一个有趣的特殊情况是当 k 趋向于 **∞** 时，意味着我们可以取系统的某一部分将其加速到一个点，这个点上，这部分话费的时间可以忽略不计。此时，我们的到 S<sub>**∞**</sub> = 1 / (1 - α)。

### 并发和并行

**并发**指的是一个通用的概念，指一个同时具有多个活动的系统；**并行**指的是用并发来使一个系统运行得更快。并行可以在在计算机系统的多个抽象层次上运用。按照系统层次结构中由高到低顺序重点强调三个层次。

1. 线程级并发

    使用线程，能够在一个进程中执行多个控制流。早期的并发执行只是通过模拟出来的，通过是一台计算机在它正在执行的进程见快速切换来实现的。这种并发形式允许多个用户同时与系统交互。例如，在一个窗口中开启 Web 浏览器，在另一个窗口运行文字处理器，同时有播放自己想听的音乐。单处理器系统是一个由单操作系统内核控制的，通过多任务切换来进行处理任务的单处理器组成的系统。多处理器系统是一个由单操作系统内核控制的多处理器组成的系统。

    ![https://i.quantuminit.com/fd4b61fe3bde4849.png](https://i.quantuminit.com/fd4b61fe3bde4849.png)

    多核处理器是将多个 CPU(称为“核”)集成到一个集成芯片上。到 2020年4月为止，笔者已知的 CPU 核心数最高是 `AMD Ryzen™ Threadripper™ 3990X Processor` 的 64 核，Intel 的核心数最高是 `Intel® Core™ i9-10980XE Extreme Edition Processor` 的 18 核。

    超线程，又可称为同时多线程（simutaneous multi-threading），是一项允许一个 CPU 执行多个控制流的技术。涉及到 CPU 某些硬件有多个备份，比如程序计数器（PC）和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算数运算的单元。

    使用多处理器，可以从两方面提高系统性能：

    - 减少了在执行多个任务时模拟并发的需要。
    - 可以使用应用程序运行更快，但程序必须使用多线程方式来书写，这些线程可以并行地高效执行。

2. 指令级并行

    在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为**指令级并行**。使用**流水线**（pipelining）来同时处理多条指令。在流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。

    如果处理器可以达到比一个周期一条指令更快的执行速率，则称之为**超标量**（super-scalar）处理器。

3. 单指令、多数据并行

    在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并发执行的操作，这种方式称为单指令、多数据，即 SIMD （Single-Instruction, Multiple-Data）并行。例如具有并行地对 8 对单精度浮点数（C 数据类型 float）做加法的指令的最新几代的 Intel 和 AMD 处理器。

    提供 SIMD 指令多是为了提高处理影像，声音和视频数据应用的执行速度。

### 计算系统中抽象的重要性

**抽象**的使用是计算机科学中最重要的概念之一。比如，为一组函数规定一个简单的应用程序接口（API）就是一个很好的编程习惯，程序员无须了解它内部的工作便可以使用这些代码。

在处理器里，**指令集架构**提供了对实际处理器硬件的抽象。

操作系统中的三种抽象：

- 文件对 I/O 设备的抽象
- 虚拟内存对程序存储器的抽象
- 进程对一个正在运行的程序的抽象

虚拟机是对整个计算机进行抽象，包括了操作系统、处理器以及程序。

## 要点总结

- 存储设备划分层次结构——从顶部到底部：CPU 寄存器，多层硬件高速缓存存储器，DRAM 主存和磁盘存储器，层次结构中的高层的存储设备作为低层设备的缓存。
- 操作系统的三抽象：文件、虚拟内存以及进程分别对 I/O 设备，主存和磁盘，处理器、主存和 I/O设备进行抽象。
- 虚拟机是对包括操作系统、处理器以及程序的整个计算机进行抽象。
- 并发是一个通用概念，指的是一个同时具有多个任务的系统。
- 并行用并发来使一个系统运行得更快。也就是说并发是实现并行的一种手段。
