---
title: csapp阅读笔记
date: 2020-04-14 18:21:24
categories: csapp
tags: [csapp,notes,深入理解计算机系统]
---

# 计算机系统漫游

计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。

![https://i.quantuminit.com/2e501a1eebe44afa.png](https://i.quantuminit.com/2e501a1eebe44afa.png)

## 信息就是位 + 上下文

hello 程序的生命周期是从一个源程序（或者说源文件）开始的，即程序员通过编辑器创建并保存的文本文件，文件名 hello.c。源程序实际上是一个由值 0 和 1 组成的位（又称比特）序列，8 个位组成的一个组，称之为**字节**。每个字节表示程序中的某些文本字符。只有 ASCII 字符构成的文件称为**文本文件**，所有其他文件都称为**二进制文件*。

![https://i.quantuminit.com/c30693fca1994049.png](https://i.quantuminit.com/c30693fca1994049.png)

hello.c 程序是以字节序列的方式储存在文件中的。hello.c 的表示方法说明了一个基本思想：系统中的所有信息————包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。

区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。

## 程序被其他程序翻译成不同的格式

hello 程序的生命周期是从一个高级 C 语言程序开始，因为这种方式能够被人读懂。但为了在系统能够运行 hello.c 程序，需要将这一我们可读的，对于计算机来说是高级语言的程序转换为机器能够理解的低级机器语言指令。然后将这些指令按照一种称为**可执行目标程序*的格式打好包，并以二进制磁盘文件的形式保存起来。目标程序也称为*可执行目标文件*。

在 Unix 上，由**编译器驱动程序**完成源文件到目标文件转化过程：

```sh
gcc -o hello hello.c
```

这个转换过程可分为四个阶段，执行这些阶段的程序构成了一个**编译系统**：

1. *预处理器*
2. *编译器*
3. *汇编器*
4. *链接器*

![https://i.quantuminit.com/d246b3ca236a4e25.png](https://i.quantuminit.com/d246b3ca236a4e25.png)

- 预处理器。该处理器（cpp）根据 # 开头字符的命令修改原始 C 程序。比如 hello.c 中的 `#include <stdio.h>`命令告诉预处理器读取系统文件 `stdio.h`的内容，并插入到 hello.c 文本文件中。通常是的到一个以.i为文件扩展名的另一个 C 程序。

- 编译器。编译器（ccl）将预处理器生成的文本文件 hello.i 翻译成包含一个汇编语言程序的文本文件 hello.s。该程序包含函数 main 的定义：

![https://i.quantuminit.com/19eb1fc16f884f2d.png](https://i.quantuminit.com/19eb1fc16f884f2d.png)

- 汇编阶段。汇编器（as）将包含汇编语言程序的 hello.s 翻译成机器语言指令，将这些命令打包成一个称为**可重定位目标程序**的格式，并保存在目标文件 hello.o 中。此时，hello.o 是一个二进制文件，其包含的 17 个字节是函数 main 的指令编码。
- 链接阶段。hello 程序调用 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。链接器负责将存在于预编译好的 printf.o文件中 中的 printf 函数，以某种方式合并到 hello.o 中来。最后得到一个可被加载到内存中由系统执行的可执行目标文件（或简称为可执行文件）。

## 了解编译系统如何工作是大有益处的

- 优化程序性能。比如一个函数的调用开销有多大？指针引用比数组索引更有效吗？为什么将循环球和的结果放到本地变量中，会比将其放到一个通过引用传递过来的参数中，运行其快很多呢？
- 理解链接时出现的错误。比如链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？在不同的 C 文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？更为严重的是，为什么有些链接错误直到运行时才会出现？
- 避免安全漏洞。缓冲区溢出错误是造成大多数网络和 Internet 服务器安全漏洞的主要原因。学习安全变成的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。学习到汇编语言的时候，将会描述栈原理和缓冲区溢出错误。

## 处理器读并解释储存在内存中的指令

在此之前，hello.c 已经被编译系统编译出了可以被载入内存运行的可执行目标文件 hello，并被存储在磁盘上。此时，我们想在 Unix 系统上执行目标程序，需要将文件输入到称为 shell 的应用程序中：

```sh
$ ./hello
hello, world
```

那么什么是 shell 呢？这个英语单词在中文中的意思是壳，贝壳。我们知道贝壳的壳很硬，这么硬有部分原因肯定是想保护内部柔软的核心的。我们知识迁移到计算机操作系统中，计算机操作系统主要由两部分组成：操作系统和 shell 组成。我们这里讲的是Unix系统。那么shell 它是一个命令行解释器，同时也是起到保护计算机操作系统内核的作用。它输出一个提示符，等待输入一个命令行，然后执行用户输入的这个命令。

![https://i.quantuminit.com/f4ec18a9d70e4133.svg](https://i.quantuminit.com/f4ec18a9d70e4133.svg)

### 系统的硬件组成

1. 总线

    贯穿整个系统的一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。有的是 4 个字节，有的是 8 个字节。

2. I/O设备

    I/O(输入/输出)设备是系统与外部世界的联系通道。这里的实例系统包括四个I/O设备：作为用户输入的鼠标和键盘，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（即磁盘）。每个 I/O 设备通过一个*控制器*或*适配器*与 I/O 总线相连。控制器和适配器之间的区别主要在于他们的封装方式。**控制器**是 I/O 设备本身或者系统的主印制电路板（即主板）上的芯片组。适配器则是一块插在主板插槽上的卡。但他们的功能都是在 I/O 总线和 I/O 设备之间传递信息。

    ![https://i.quantuminit.com/da08e95947d2461b.png](https://i.quantuminit.com/da08e95947d2461b.png)

3. 主存

    *主存*是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是一组*动态随机存取存储器（DRAM）芯片组成。而从逻辑上来说，存储器是一个线性的字节数组，每个自己都有其唯一的地址（数组索引），这些地址是从零开始的。

4. 处理器

    *中央处理单元（CPU）*，简称（*处理器*），是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或*寄存器*），称为*程序计数器*(PC)。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。
